<!DOCTYPE html>
<html>

<head>

    <meta charset="utf-8">
    <title>BoomBoom - Stage 3</title>
    <link rel="stylesheet" type="text/css" href="css/ButtonStyle.css">
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
        }

        body {
            background-color: #ffffff;
            margin: 0;
            overflow: hidden;
            font-family: arial;
        }

        #power {
            position: fixed;
            top: 0;
            center: 0;
            color: white;
            padding: 5px;
            text-align: center;
            font-size: 30pt;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        #crosshair{
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2%;
        transform: translate(-50%, -50%);
        }
        #game_hud{
        visibility: hidden;
        }

        #instructions{
            width: 100%;
            height: 100%;
            display: -webkit-box;
            display: -moz-box;
            display: box;
            -webkit-box-orient: horizontal;
            -moz-box-orient: horizontal;
            box-orient: horizontal;
            -webkit-box-pack: center;
            -moz-box-pack: center;
            box-pack: center;
            -webkit-box-align: center;
            -moz-box-align: center;
            box-align: center;
            color: #ffffff;
            text-align: center;
            cursor: pointer;
        }
    </style>

</head>


<body>

    <script src="../libs/Three.js"></script>

    <script src="../build/cannon.js"></script>

    <script src="js/PointerLockControls.js"></script>

    <script src="js/Stage1.js"></script>

    <script src="js/Stage3.js"></script>
    <script scr="js/MoveCannon.js"></script>

    <script src="https://cdn.rawgit.com/mrdoob/three.js/r69/examples/js/loaders/ColladaLoader.js"></script>
    <script>var num_try;</script>
    <div id="blocker">
        <div id="instructions">
            <span id = 'text' style="font-size:36px">stage 3<br />
            If you fall green block, stage cleared!</span>
            
            <br />
            <button class="next" onClick="location.href='threejs_fps4.html'"> Next Stage</button>
            <button class="home" onClick="location.href='boomboom.html'"> HOME</button>
            <button class="done" onClick='self.close()'> START </button>
        </div>
    </div>
    <div id='power'>0</div>
	    <div id="game_hud">
      <img id="crosshair" src="images_stage/crosshair.png" />
    </div>
    <script>
        var sphereShape, sphereBody, world, physicsMaterial, walls = [], balls = [], ballMeshes = [], boxes = [], boxMeshes = [];
        var stage_clear = false;
        var reset_state = false;
        var camera, scene, renderer;
        var geometry, material, mesh;
        var controls, time = Date.now();
        var blocker = document.getElementById('blocker');
        var instructions = document.getElementById('instructions');
        // var next = document.getElementById("next");
        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

        if (havePointerLock) {
            var element = document.body;
            var pointerlockchange = function (event) {
                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                    controls.enabled = true;
                    blocker.style.display = 'none';
					document.getElementById("game_hud").style.visibility = 'visible';
                } else {
                    controls.enabled = false;
                    blocker.style.display = '-webkit-box';
                    blocker.style.display = '-moz-box';
                    blocker.style.display = 'box';
                    instructions.style.display = '';
					document.getElementById("game_hud").style.visibility = 'hidden';
                }
            }
            var pointerlockerror = function (event) {
                instructions.style.display = '';
            }
            // Hook pointer lock state change events

            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
            instructions.addEventListener('click', function (event) {

                var loader = new THREE.ColladaLoader();
    loader.options.convertUpAxis = true;

    var custom=JSON.parse(localStorage.getItem('color'));
    console.log(custom);

    loader.load(custom, function(collada) {
    // collada.scene.scale.set(0.0001, 0.0001, 0.0001);
    // scene.add(collada.scene);
    
    dae = collada.scene;
    
   // var skin = collada.skins[0];
   // dae.position.set(0, 0, 0);

    
    
    dae.scale.x = dae.scale.y = dae.scale.z = 0.04;
    dae.position.set(0, -1.1, 0);

    
    var scope = this;
    var PI_2 = Math.PI * 2;
    var onMouseMoveForCannon = function (event) {

        if (scope.enabled === false) return;

        var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
        var movementZ = event.movementZ || event.mozMovementZ || event.webkitMovementZ || 0;

        dae.rotation.y -= movementX * 0.002;
        dae.rotation.x -= movementY * 0.002;
        dae.rotation.z -= movementZ * 0.002;

        dae.rotation.x = Math.max(- PI_2, Math.min(PI_2, dae.rotation.x));
        // cannon.rotation.y = Math.max(- PI_2, Math.min(PI_2, cannon.rotation.y));
        //dae.rotation.z = Math.max(-PI_2, Math.min(PI_2, dae.rotation.z));
        dae.updateMatrix();
    
    
        scene.add(dae);


    };
    window.addEventListener('mousemove', onMouseMoveForCannon, false);



    
    }); 



                instructions.style.display = 'none';
                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                if (/Firefox/i.test(navigator.userAgent)) {
                    var fullscreenchange = function (event) {
                        if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {
                            document.removeEventListener('fullscreenchange', fullscreenchange);
                            document.removeEventListener('mozfullscreenchange', fullscreenchange);
                            element.requestPointerLock();
                        }
                    }
                    document.addEventListener('fullscreenchange', fullscreenchange, false);
                    document.addEventListener('mozfullscreenchange', fullscreenchange, false);
                    element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                    element.requestFullscreen();
                } else {
                    element.requestPointerLock();
                }
            }, false);
        } else {
            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
        }

        var stageStage = 3;
        switch (stageStage) {
            case 1:
                stage1();
                break;
            case 2:
                stage2();
                break;
            case 3:
                stage3();
                break;
        }
        //Erased innitCannon(), init(), anmaite() code
        var ballShape = new CANNON.Sphere(0.2);
        var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);
        var shootDirection = new THREE.Vector3();
        var shootVelo = 5;
        var projector = new THREE.Projector();
        function getShootDir(targetVec) {
            var vector = targetVec;
            targetVec.set(0, 0, 1);
            projector.unprojectVector(vector, camera);
            var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize());
            targetVec.copy(ray.direction);
        }
        num_try = 0;

        window.addEventListener("mousedown", function (e) {

            timer = setInterval(function () {
                shootVelo += 2;
            }, 100);

        });

        window.addEventListener("mouseup", function (e) {
            clearInterval(timer);
            console.log(shootVelo);
            power.innerHTML = shootVelo;
            num_try = num_try + 1;
            console.log(num_try)
            if (controls.enabled == true && num_try < 50) {
                var x = sphereBody.position.x;
                var y = sphereBody.position.y;
                var z = sphereBody.position.z;
                var ballBody = new CANNON.Body({ mass: 1 });
                ballBody.addShape(ballShape);
                var ballMesh = new THREE.Mesh(ballGeometry, material);
                world.addBody(ballBody);
                scene.add(ballMesh);
                ballMesh.castShadow = true;
                ballMesh.receiveShadow = true;
                balls.push(ballBody);
                ballMeshes.push(ballMesh);
                getShootDir(shootDirection);
                ballBody.velocity.set(shootDirection.x * shootVelo,
                    shootDirection.y * shootVelo,
                    shootDirection.z * shootVelo);

                // Move the ball outside the player sphere
                x += shootDirection.x * (sphereShape.radius * 1.02 + ballShape.radius);
                y += shootDirection.y * (sphereShape.radius * 1.02 + ballShape.radius);
                z += shootDirection.z * (sphereShape.radius * 1.02 + ballShape.radius);
                ballBody.position.set(x, y, z);
                ballMesh.position.set(x, y, z);
                shootVelo = 5;
            }
            else {
                console.log("out of ball");
            }
        });

        function clear() {

            if (stage_clear === true && reset_state === false) {
                console.log(stage_clear);
                controls.enabled = false;
                blocker.style.display = '-webkit-box';
                blocker.style.display = '-moz-box';
                blocker.style.display = 'box';
                text.innerHTML = "Clear Stage3!!"
                instructions.style.display = '';
            }
            //clear 화면 없애기
            if (stage_clear === true) {
                window.addEventListener("click", function () {
                    controls.enabled = true;
                    console.log('clicked');
                    reset_state = true;
                    console.log(reset_state);
                    blocker.style.display = 'none';
                    stage_clear = false;
                    console.log(stage_clear);
                    // reset_state = false;
                    // console.log(reset_state);
                    //scene.remove(boxMeshes[0]);
                    //scene.remove(boxMeshes[1]);
                    console.log(boxes.length + 'before');
                    boxes.splice(0, boxes.length)
                    boxMeshes.splice(0, boxMeshes.length)
                    console.log(boxes.length + 'after');
                    //stageStage++;
                });
            }

        }
    </script>

</body>

</html>